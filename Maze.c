#include <stdio.h>
int m[18][18] = { //maze
             {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},//2는 미로의 벽
             {2,0,0,0,2,0,0,0,2,2,0,0,0,0,0,2,2,2},//0은 갈수있는길
             {2,0,2,2,0,2,0,0,0,2,0,2,2,2,0,0,2,2},
             {2,0,2,0,0,2,0,0,2,2,2,2,2,2,0,2,2,2},
             {2,0,2,0,2,0,2,0,2,2,2,2,2,2,0,2,2,2},
             {2,0,0,0,0,0,2,0,2,0,0,2,2,0,0,2,2,2},
             {2,2,0,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2},
             {2,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,2},
             {2,0,2,2,2,2,0,0,2,0,2,2,2,2,0,2,0,2},
             {2,0,2,2,0,0,0,0,2,0,2,2,2,2,0,2,0,2},
             {2,0,2,2,0,2,0,0,2,0,2,2,2,2,0,2,0,2},
             {2,0,2,2,2,2,0,0,2,0,2,2,2,2,0,2,2,2},
             {2,0,2,2,2,2,0,0,2,0,2,2,2,2,0,2,0,2},
             {2,0,2,2,2,2,0,0,0,0,0,0,0,0,0,2,0,2},
             {2,0,2,2,2,2,0,0,2,0,2,2,2,2,0,0,0,2},
             {2,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,0,2},
             {2,0,0,0,0,0,0,0,2,0,2,2,2,2,0,0,0,2},
             {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
};
int Si, Sj, Ei, Ej;//start 출발행렬(si,sj) end 도착행렬(ei,ej)
int success, top, Path_i[100], Path_j[100];
//success : 미로 성공여부
// top: 시스템 스택에 저장되는 위치
//Path_i,Path_j : 미로에서 지나간 길을 저장함 i는 행 j는 열
int visit(int, int);
int main() {
    top = 0;//스택의 top 변수를 0으로 초기화
    success = 0;//미로 탈출 여부
    printf("=== 미로 탈출 경로 찾기 게임 ===\n");
    Si = 1, Sj = 1;//출발점 m 배열의 1행 1열 위치
    Ei = 16, Ej = 16;//도착점 m 배열의 16행 16열 위치
    if (visit(Si, Sj) == 0)
        printf("미로의 출구를 찾을 수 없음\n");
    else
        printf("미로의 모든경로를 찾았음\n");
    return 0;
}

void printPath() {
    for (int i = 0; i < top; i++)
        printf("[%d,%d]", Path_i[i], Path_j[i]);
}

int visit(int i, int j) {//i , j 행과 열(row,column)
    static int pathCount = 1;//찾은 경로 수 
    m[i][j] = 1;
    Path_i[top] = i;
    Path_j[top++] = j;
    //top++
    if (i == Ei && j == Ej) {//도착했을때 ,미로탐색성공
        printf("찾은경로 %d번\n", pathCount++);
        printPath();
        success = 1;
    }

    if (m[i][j + 1] == 0) //배열 오른쪽으로 이동
        visit(i, j + 1);
    if (m[i+1][j] == 0) //배열 아래행 이동
        visit(i +1, j); 
    if (m[i][j - 1] == 0) //배열 왼쪽 이동
        visit(i, j - 1); 
    if (m[i-1][j] == 0) //배열 위쪽으로 이동
        visit(i-1, j);
    top--;
    m[i][j] = 0;//길이 막혀있을 때 이전길로 돌아가면서 1을 0으로 변경
    return success;
}
